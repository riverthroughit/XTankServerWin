// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: XTankMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_XTankMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_XTankMsg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_XTankMsg_2eproto;
namespace XTankMsg {
class GameForwardNtf;
struct GameForwardNtfDefaultTypeInternal;
extern GameForwardNtfDefaultTypeInternal _GameForwardNtf_default_instance_;
class GameInitNtf;
struct GameInitNtfDefaultTypeInternal;
extern GameInitNtfDefaultTypeInternal _GameInitNtf_default_instance_;
class GameReadyAck;
struct GameReadyAckDefaultTypeInternal;
extern GameReadyAckDefaultTypeInternal _GameReadyAck_default_instance_;
class GameReadyReq;
struct GameReadyReqDefaultTypeInternal;
extern GameReadyReqDefaultTypeInternal _GameReadyReq_default_instance_;
class GameStartNtf;
struct GameStartNtfDefaultTypeInternal;
extern GameStartNtfDefaultTypeInternal _GameStartNtf_default_instance_;
class LobbyNtf;
struct LobbyNtfDefaultTypeInternal;
extern LobbyNtfDefaultTypeInternal _LobbyNtf_default_instance_;
class LobbyNtf_RoomInfo;
struct LobbyNtf_RoomInfoDefaultTypeInternal;
extern LobbyNtf_RoomInfoDefaultTypeInternal _LobbyNtf_RoomInfo_default_instance_;
class LoginAck;
struct LoginAckDefaultTypeInternal;
extern LoginAckDefaultTypeInternal _LoginAck_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LogoutAck;
struct LogoutAckDefaultTypeInternal;
extern LogoutAckDefaultTypeInternal _LogoutAck_default_instance_;
class LogoutReq;
struct LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class PlayerChaseUpNtf;
struct PlayerChaseUpNtfDefaultTypeInternal;
extern PlayerChaseUpNtfDefaultTypeInternal _PlayerChaseUpNtf_default_instance_;
class PlayerCutInNtf;
struct PlayerCutInNtfDefaultTypeInternal;
extern PlayerCutInNtfDefaultTypeInternal _PlayerCutInNtf_default_instance_;
class PlayerCutInReq;
struct PlayerCutInReqDefaultTypeInternal;
extern PlayerCutInReqDefaultTypeInternal _PlayerCutInReq_default_instance_;
class PlayerExitAck;
struct PlayerExitAckDefaultTypeInternal;
extern PlayerExitAckDefaultTypeInternal _PlayerExitAck_default_instance_;
class PlayerExitReq;
struct PlayerExitReqDefaultTypeInternal;
extern PlayerExitReqDefaultTypeInternal _PlayerExitReq_default_instance_;
class PlayerId;
struct PlayerIdDefaultTypeInternal;
extern PlayerIdDefaultTypeInternal _PlayerId_default_instance_;
class PlayerInputNtf;
struct PlayerInputNtfDefaultTypeInternal;
extern PlayerInputNtfDefaultTypeInternal _PlayerInputNtf_default_instance_;
class PlayerReadyAck;
struct PlayerReadyAckDefaultTypeInternal;
extern PlayerReadyAckDefaultTypeInternal _PlayerReadyAck_default_instance_;
class PlayerReadyCancelAck;
struct PlayerReadyCancelAckDefaultTypeInternal;
extern PlayerReadyCancelAckDefaultTypeInternal _PlayerReadyCancelAck_default_instance_;
class PlayerReadyCancelReq;
struct PlayerReadyCancelReqDefaultTypeInternal;
extern PlayerReadyCancelReqDefaultTypeInternal _PlayerReadyCancelReq_default_instance_;
class PlayerReadyReq;
struct PlayerReadyReqDefaultTypeInternal;
extern PlayerReadyReqDefaultTypeInternal _PlayerReadyReq_default_instance_;
class RoomCreateAck;
struct RoomCreateAckDefaultTypeInternal;
extern RoomCreateAckDefaultTypeInternal _RoomCreateAck_default_instance_;
class RoomCreateReq;
struct RoomCreateReqDefaultTypeInternal;
extern RoomCreateReqDefaultTypeInternal _RoomCreateReq_default_instance_;
class RoomExitAck;
struct RoomExitAckDefaultTypeInternal;
extern RoomExitAckDefaultTypeInternal _RoomExitAck_default_instance_;
class RoomExitReq;
struct RoomExitReqDefaultTypeInternal;
extern RoomExitReqDefaultTypeInternal _RoomExitReq_default_instance_;
class RoomJoinAck;
struct RoomJoinAckDefaultTypeInternal;
extern RoomJoinAckDefaultTypeInternal _RoomJoinAck_default_instance_;
class RoomJoinReq;
struct RoomJoinReqDefaultTypeInternal;
extern RoomJoinReqDefaultTypeInternal _RoomJoinReq_default_instance_;
class RoomNtf;
struct RoomNtfDefaultTypeInternal;
extern RoomNtfDefaultTypeInternal _RoomNtf_default_instance_;
class RoomNtf_PlayerState;
struct RoomNtf_PlayerStateDefaultTypeInternal;
extern RoomNtf_PlayerStateDefaultTypeInternal _RoomNtf_PlayerState_default_instance_;
}  // namespace XTankMsg
PROTOBUF_NAMESPACE_OPEN
template<> ::XTankMsg::GameForwardNtf* Arena::CreateMaybeMessage<::XTankMsg::GameForwardNtf>(Arena*);
template<> ::XTankMsg::GameInitNtf* Arena::CreateMaybeMessage<::XTankMsg::GameInitNtf>(Arena*);
template<> ::XTankMsg::GameReadyAck* Arena::CreateMaybeMessage<::XTankMsg::GameReadyAck>(Arena*);
template<> ::XTankMsg::GameReadyReq* Arena::CreateMaybeMessage<::XTankMsg::GameReadyReq>(Arena*);
template<> ::XTankMsg::GameStartNtf* Arena::CreateMaybeMessage<::XTankMsg::GameStartNtf>(Arena*);
template<> ::XTankMsg::LobbyNtf* Arena::CreateMaybeMessage<::XTankMsg::LobbyNtf>(Arena*);
template<> ::XTankMsg::LobbyNtf_RoomInfo* Arena::CreateMaybeMessage<::XTankMsg::LobbyNtf_RoomInfo>(Arena*);
template<> ::XTankMsg::LoginAck* Arena::CreateMaybeMessage<::XTankMsg::LoginAck>(Arena*);
template<> ::XTankMsg::LoginReq* Arena::CreateMaybeMessage<::XTankMsg::LoginReq>(Arena*);
template<> ::XTankMsg::LogoutAck* Arena::CreateMaybeMessage<::XTankMsg::LogoutAck>(Arena*);
template<> ::XTankMsg::LogoutReq* Arena::CreateMaybeMessage<::XTankMsg::LogoutReq>(Arena*);
template<> ::XTankMsg::PlayerChaseUpNtf* Arena::CreateMaybeMessage<::XTankMsg::PlayerChaseUpNtf>(Arena*);
template<> ::XTankMsg::PlayerCutInNtf* Arena::CreateMaybeMessage<::XTankMsg::PlayerCutInNtf>(Arena*);
template<> ::XTankMsg::PlayerCutInReq* Arena::CreateMaybeMessage<::XTankMsg::PlayerCutInReq>(Arena*);
template<> ::XTankMsg::PlayerExitAck* Arena::CreateMaybeMessage<::XTankMsg::PlayerExitAck>(Arena*);
template<> ::XTankMsg::PlayerExitReq* Arena::CreateMaybeMessage<::XTankMsg::PlayerExitReq>(Arena*);
template<> ::XTankMsg::PlayerId* Arena::CreateMaybeMessage<::XTankMsg::PlayerId>(Arena*);
template<> ::XTankMsg::PlayerInputNtf* Arena::CreateMaybeMessage<::XTankMsg::PlayerInputNtf>(Arena*);
template<> ::XTankMsg::PlayerReadyAck* Arena::CreateMaybeMessage<::XTankMsg::PlayerReadyAck>(Arena*);
template<> ::XTankMsg::PlayerReadyCancelAck* Arena::CreateMaybeMessage<::XTankMsg::PlayerReadyCancelAck>(Arena*);
template<> ::XTankMsg::PlayerReadyCancelReq* Arena::CreateMaybeMessage<::XTankMsg::PlayerReadyCancelReq>(Arena*);
template<> ::XTankMsg::PlayerReadyReq* Arena::CreateMaybeMessage<::XTankMsg::PlayerReadyReq>(Arena*);
template<> ::XTankMsg::RoomCreateAck* Arena::CreateMaybeMessage<::XTankMsg::RoomCreateAck>(Arena*);
template<> ::XTankMsg::RoomCreateReq* Arena::CreateMaybeMessage<::XTankMsg::RoomCreateReq>(Arena*);
template<> ::XTankMsg::RoomExitAck* Arena::CreateMaybeMessage<::XTankMsg::RoomExitAck>(Arena*);
template<> ::XTankMsg::RoomExitReq* Arena::CreateMaybeMessage<::XTankMsg::RoomExitReq>(Arena*);
template<> ::XTankMsg::RoomJoinAck* Arena::CreateMaybeMessage<::XTankMsg::RoomJoinAck>(Arena*);
template<> ::XTankMsg::RoomJoinReq* Arena::CreateMaybeMessage<::XTankMsg::RoomJoinReq>(Arena*);
template<> ::XTankMsg::RoomNtf* Arena::CreateMaybeMessage<::XTankMsg::RoomNtf>(Arena*);
template<> ::XTankMsg::RoomNtf_PlayerState* Arena::CreateMaybeMessage<::XTankMsg::RoomNtf_PlayerState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XTankMsg {

enum MSG : int {
  NONE = 0,
  LOGIN_REQ = 1,
  LOGIN_ACK = 2,
  LOGOUT_REQ = 3,
  LOGOUT_ACK = 4,
  LOBBY_NTF = 5,
  ROOM_CREATE_REQ = 6,
  ROOM_CREATE_ACK = 7,
  ROOM_JOIN_REQ = 8,
  ROOM_JOIN_ACK = 9,
  ROOM_EXIT_REQ = 10,
  ROOM_EXIT_ACK = 11,
  ROOM_NTF = 12,
  PLAYER_READY_REQ = 13,
  PLAYER_READY_ACK = 14,
  PLAYER_READY_CANCEL_REQ = 15,
  PLAYER_READY_CANCEL_ACK = 16,
  GAME_READY_REQ = 17,
  GAME_INIT_NTF = 18,
  GAME_READY_ACK = 19,
  GAME_START_NTF = 20,
  PLAYER_INPUT_NTF = 21,
  GAME_FORWARD_NTF = 22,
  PLAYER_EXIT_REQ = 23,
  PLAYER_EXIT_ACK = 24,
  PLAYER_CUT_IN_REQ = 25,
  PLAYER_CUT_IN_NTF = 26,
  PLAYER_CHASE_UP_NTF = 27,
  MSG_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MSG_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MSG_IsValid(int value);
constexpr MSG MSG_MIN = NONE;
constexpr MSG MSG_MAX = PLAYER_CHASE_UP_NTF;
constexpr int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MSG_descriptor();
template<typename T>
inline const std::string& MSG_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MSG>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MSG_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MSG_descriptor(), enum_t_value);
}
inline bool MSG_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MSG* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class PlayerId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerId) */ {
 public:
  inline PlayerId() : PlayerId(nullptr) {}
  ~PlayerId() override;
  explicit constexpr PlayerId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerId(const PlayerId& from);
  PlayerId(PlayerId&& from) noexcept
    : PlayerId() {
    *this = ::std::move(from);
  }

  inline PlayerId& operator=(const PlayerId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerId& operator=(PlayerId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerId* internal_default_instance() {
    return reinterpret_cast<const PlayerId*>(
               &_PlayerId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerId& a, PlayerId& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerId";
  }
  protected:
  explicit PlayerId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint64 pid = 2;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit constexpr LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LoginAck) */ {
 public:
  inline LoginAck() : LoginAck(nullptr) {}
  ~LoginAck() override;
  explicit constexpr LoginAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAck(const LoginAck& from);
  LoginAck(LoginAck&& from) noexcept
    : LoginAck() {
    *this = ::std::move(from);
  }

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAck& operator=(LoginAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAck* internal_default_instance() {
    return reinterpret_cast<const LoginAck*>(
               &_LoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginAck& a, LoginAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LoginAck";
  }
  protected:
  explicit LoginAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LoginAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LogoutReq) */ {
 public:
  inline LogoutReq() : LogoutReq(nullptr) {}
  ~LogoutReq() override;
  explicit constexpr LogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReq(const LogoutReq& from);
  LogoutReq(LogoutReq&& from) noexcept
    : LogoutReq() {
    *this = ::std::move(from);
  }

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReq& operator=(LogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LogoutReq& a, LogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogoutReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LogoutReq";
  }
  protected:
  explicit LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.LogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LogoutAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LogoutAck) */ {
 public:
  inline LogoutAck() : LogoutAck(nullptr) {}
  ~LogoutAck() override;
  explicit constexpr LogoutAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutAck(const LogoutAck& from);
  LogoutAck(LogoutAck&& from) noexcept
    : LogoutAck() {
    *this = ::std::move(from);
  }

  inline LogoutAck& operator=(const LogoutAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutAck& operator=(LogoutAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutAck* internal_default_instance() {
    return reinterpret_cast<const LogoutAck*>(
               &_LogoutAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutAck& a, LogoutAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogoutAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LogoutAck";
  }
  protected:
  explicit LogoutAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LogoutAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LobbyNtf_RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LobbyNtf.RoomInfo) */ {
 public:
  inline LobbyNtf_RoomInfo() : LobbyNtf_RoomInfo(nullptr) {}
  ~LobbyNtf_RoomInfo() override;
  explicit constexpr LobbyNtf_RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyNtf_RoomInfo(const LobbyNtf_RoomInfo& from);
  LobbyNtf_RoomInfo(LobbyNtf_RoomInfo&& from) noexcept
    : LobbyNtf_RoomInfo() {
    *this = ::std::move(from);
  }

  inline LobbyNtf_RoomInfo& operator=(const LobbyNtf_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyNtf_RoomInfo& operator=(LobbyNtf_RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyNtf_RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyNtf_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const LobbyNtf_RoomInfo*>(
               &_LobbyNtf_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LobbyNtf_RoomInfo& a, LobbyNtf_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyNtf_RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyNtf_RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyNtf_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyNtf_RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyNtf_RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyNtf_RoomInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyNtf_RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LobbyNtf.RoomInfo";
  }
  protected:
  explicit LobbyNtf_RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPlayerNumFieldNumber = 2,
    kInGameFieldNumber = 3,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 playerNum = 2;
  void clear_playernum();
  uint32_t playernum() const;
  void set_playernum(uint32_t value);
  private:
  uint32_t _internal_playernum() const;
  void _internal_set_playernum(uint32_t value);
  public:

  // bool inGame = 3;
  void clear_ingame();
  bool ingame() const;
  void set_ingame(bool value);
  private:
  bool _internal_ingame() const;
  void _internal_set_ingame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LobbyNtf.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t id_;
  uint32_t playernum_;
  bool ingame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LobbyNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LobbyNtf) */ {
 public:
  inline LobbyNtf() : LobbyNtf(nullptr) {}
  ~LobbyNtf() override;
  explicit constexpr LobbyNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyNtf(const LobbyNtf& from);
  LobbyNtf(LobbyNtf&& from) noexcept
    : LobbyNtf() {
    *this = ::std::move(from);
  }

  inline LobbyNtf& operator=(const LobbyNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyNtf& operator=(LobbyNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyNtf* internal_default_instance() {
    return reinterpret_cast<const LobbyNtf*>(
               &_LobbyNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LobbyNtf& a, LobbyNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LobbyNtf";
  }
  protected:
  explicit LobbyNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LobbyNtf_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .XTankMsg.LobbyNtf.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::XTankMsg::LobbyNtf_RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >*
      mutable_rooms();
  private:
  const ::XTankMsg::LobbyNtf_RoomInfo& _internal_rooms(int index) const;
  ::XTankMsg::LobbyNtf_RoomInfo* _internal_add_rooms();
  public:
  const ::XTankMsg::LobbyNtf_RoomInfo& rooms(int index) const;
  ::XTankMsg::LobbyNtf_RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:XTankMsg.LobbyNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo > rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomCreateReq) */ {
 public:
  inline RoomCreateReq() : RoomCreateReq(nullptr) {}
  ~RoomCreateReq() override;
  explicit constexpr RoomCreateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomCreateReq(const RoomCreateReq& from);
  RoomCreateReq(RoomCreateReq&& from) noexcept
    : RoomCreateReq() {
    *this = ::std::move(from);
  }

  inline RoomCreateReq& operator=(const RoomCreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateReq& operator=(RoomCreateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCreateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomCreateReq* internal_default_instance() {
    return reinterpret_cast<const RoomCreateReq*>(
               &_RoomCreateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoomCreateReq& a, RoomCreateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCreateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCreateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomCreateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomCreateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomCreateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomCreateReq";
  }
  protected:
  explicit RoomCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomCreateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomCreateAck) */ {
 public:
  inline RoomCreateAck() : RoomCreateAck(nullptr) {}
  ~RoomCreateAck() override;
  explicit constexpr RoomCreateAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomCreateAck(const RoomCreateAck& from);
  RoomCreateAck(RoomCreateAck&& from) noexcept
    : RoomCreateAck() {
    *this = ::std::move(from);
  }

  inline RoomCreateAck& operator=(const RoomCreateAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateAck& operator=(RoomCreateAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCreateAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomCreateAck* internal_default_instance() {
    return reinterpret_cast<const RoomCreateAck*>(
               &_RoomCreateAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomCreateAck& a, RoomCreateAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCreateAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCreateAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomCreateAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomCreateAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomCreateAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomCreateAck";
  }
  protected:
  explicit RoomCreateAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomCreateAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomJoinReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomJoinReq) */ {
 public:
  inline RoomJoinReq() : RoomJoinReq(nullptr) {}
  ~RoomJoinReq() override;
  explicit constexpr RoomJoinReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomJoinReq(const RoomJoinReq& from);
  RoomJoinReq(RoomJoinReq&& from) noexcept
    : RoomJoinReq() {
    *this = ::std::move(from);
  }

  inline RoomJoinReq& operator=(const RoomJoinReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomJoinReq& operator=(RoomJoinReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomJoinReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomJoinReq* internal_default_instance() {
    return reinterpret_cast<const RoomJoinReq*>(
               &_RoomJoinReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoomJoinReq& a, RoomJoinReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomJoinReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomJoinReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomJoinReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomJoinReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomJoinReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomJoinReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomJoinReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomJoinReq";
  }
  protected:
  explicit RoomJoinReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // uint64 roomId = 2;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomJoinReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  uint64_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomJoinAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomJoinAck) */ {
 public:
  inline RoomJoinAck() : RoomJoinAck(nullptr) {}
  ~RoomJoinAck() override;
  explicit constexpr RoomJoinAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomJoinAck(const RoomJoinAck& from);
  RoomJoinAck(RoomJoinAck&& from) noexcept
    : RoomJoinAck() {
    *this = ::std::move(from);
  }

  inline RoomJoinAck& operator=(const RoomJoinAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomJoinAck& operator=(RoomJoinAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomJoinAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomJoinAck* internal_default_instance() {
    return reinterpret_cast<const RoomJoinAck*>(
               &_RoomJoinAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RoomJoinAck& a, RoomJoinAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomJoinAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomJoinAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomJoinAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomJoinAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomJoinAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomJoinAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomJoinAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomJoinAck";
  }
  protected:
  explicit RoomJoinAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomJoinAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomExitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomExitReq) */ {
 public:
  inline RoomExitReq() : RoomExitReq(nullptr) {}
  ~RoomExitReq() override;
  explicit constexpr RoomExitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomExitReq(const RoomExitReq& from);
  RoomExitReq(RoomExitReq&& from) noexcept
    : RoomExitReq() {
    *this = ::std::move(from);
  }

  inline RoomExitReq& operator=(const RoomExitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomExitReq& operator=(RoomExitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomExitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomExitReq* internal_default_instance() {
    return reinterpret_cast<const RoomExitReq*>(
               &_RoomExitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RoomExitReq& a, RoomExitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomExitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomExitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomExitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomExitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomExitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomExitReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomExitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomExitReq";
  }
  protected:
  explicit RoomExitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomExitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomExitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomExitAck) */ {
 public:
  inline RoomExitAck() : RoomExitAck(nullptr) {}
  ~RoomExitAck() override;
  explicit constexpr RoomExitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomExitAck(const RoomExitAck& from);
  RoomExitAck(RoomExitAck&& from) noexcept
    : RoomExitAck() {
    *this = ::std::move(from);
  }

  inline RoomExitAck& operator=(const RoomExitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomExitAck& operator=(RoomExitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomExitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomExitAck* internal_default_instance() {
    return reinterpret_cast<const RoomExitAck*>(
               &_RoomExitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RoomExitAck& a, RoomExitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomExitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomExitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomExitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomExitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomExitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomExitAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomExitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomExitAck";
  }
  protected:
  explicit RoomExitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomExitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomNtf_PlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomNtf.PlayerState) */ {
 public:
  inline RoomNtf_PlayerState() : RoomNtf_PlayerState(nullptr) {}
  ~RoomNtf_PlayerState() override;
  explicit constexpr RoomNtf_PlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomNtf_PlayerState(const RoomNtf_PlayerState& from);
  RoomNtf_PlayerState(RoomNtf_PlayerState&& from) noexcept
    : RoomNtf_PlayerState() {
    *this = ::std::move(from);
  }

  inline RoomNtf_PlayerState& operator=(const RoomNtf_PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomNtf_PlayerState& operator=(RoomNtf_PlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomNtf_PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomNtf_PlayerState* internal_default_instance() {
    return reinterpret_cast<const RoomNtf_PlayerState*>(
               &_RoomNtf_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RoomNtf_PlayerState& a, RoomNtf_PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomNtf_PlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomNtf_PlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomNtf_PlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomNtf_PlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomNtf_PlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomNtf_PlayerState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomNtf_PlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomNtf.PlayerState";
  }
  protected:
  explicit RoomNtf_PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // bool ready = 2;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomNtf.PlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  bool ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomNtf) */ {
 public:
  inline RoomNtf() : RoomNtf(nullptr) {}
  ~RoomNtf() override;
  explicit constexpr RoomNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomNtf(const RoomNtf& from);
  RoomNtf(RoomNtf&& from) noexcept
    : RoomNtf() {
    *this = ::std::move(from);
  }

  inline RoomNtf& operator=(const RoomNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomNtf& operator=(RoomNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomNtf* internal_default_instance() {
    return reinterpret_cast<const RoomNtf*>(
               &_RoomNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RoomNtf& a, RoomNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomNtf";
  }
  protected:
  explicit RoomNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoomNtf_PlayerState PlayerState;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerStatesFieldNumber = 2,
    kRoomIdFieldNumber = 1,
    kIsInGameFieldNumber = 3,
  };
  // repeated .XTankMsg.RoomNtf.PlayerState playerStates = 2;
  int playerstates_size() const;
  private:
  int _internal_playerstates_size() const;
  public:
  void clear_playerstates();
  ::XTankMsg::RoomNtf_PlayerState* mutable_playerstates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >*
      mutable_playerstates();
  private:
  const ::XTankMsg::RoomNtf_PlayerState& _internal_playerstates(int index) const;
  ::XTankMsg::RoomNtf_PlayerState* _internal_add_playerstates();
  public:
  const ::XTankMsg::RoomNtf_PlayerState& playerstates(int index) const;
  ::XTankMsg::RoomNtf_PlayerState* add_playerstates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >&
      playerstates() const;

  // uint32 roomId = 1;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // bool IsInGame = 3;
  void clear_isingame();
  bool isingame() const;
  void set_isingame(bool value);
  private:
  bool _internal_isingame() const;
  void _internal_set_isingame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState > playerstates_;
  uint32_t roomid_;
  bool isingame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerReadyReq) */ {
 public:
  inline PlayerReadyReq() : PlayerReadyReq(nullptr) {}
  ~PlayerReadyReq() override;
  explicit constexpr PlayerReadyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyReq(const PlayerReadyReq& from);
  PlayerReadyReq(PlayerReadyReq&& from) noexcept
    : PlayerReadyReq() {
    *this = ::std::move(from);
  }

  inline PlayerReadyReq& operator=(const PlayerReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyReq& operator=(PlayerReadyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyReq* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyReq*>(
               &_PlayerReadyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PlayerReadyReq& a, PlayerReadyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReadyReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerReadyReq";
  }
  protected:
  explicit PlayerReadyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerReadyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerReadyAck) */ {
 public:
  inline PlayerReadyAck() : PlayerReadyAck(nullptr) {}
  ~PlayerReadyAck() override;
  explicit constexpr PlayerReadyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyAck(const PlayerReadyAck& from);
  PlayerReadyAck(PlayerReadyAck&& from) noexcept
    : PlayerReadyAck() {
    *this = ::std::move(from);
  }

  inline PlayerReadyAck& operator=(const PlayerReadyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyAck& operator=(PlayerReadyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyAck* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyAck*>(
               &_PlayerReadyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PlayerReadyAck& a, PlayerReadyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReadyAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerReadyAck";
  }
  protected:
  explicit PlayerReadyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerReadyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerReadyCancelReq) */ {
 public:
  inline PlayerReadyCancelReq() : PlayerReadyCancelReq(nullptr) {}
  ~PlayerReadyCancelReq() override;
  explicit constexpr PlayerReadyCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyCancelReq(const PlayerReadyCancelReq& from);
  PlayerReadyCancelReq(PlayerReadyCancelReq&& from) noexcept
    : PlayerReadyCancelReq() {
    *this = ::std::move(from);
  }

  inline PlayerReadyCancelReq& operator=(const PlayerReadyCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyCancelReq& operator=(PlayerReadyCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyCancelReq* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyCancelReq*>(
               &_PlayerReadyCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlayerReadyCancelReq& a, PlayerReadyCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyCancelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReadyCancelReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyCancelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerReadyCancelReq";
  }
  protected:
  explicit PlayerReadyCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerReadyCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyCancelAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerReadyCancelAck) */ {
 public:
  inline PlayerReadyCancelAck() : PlayerReadyCancelAck(nullptr) {}
  ~PlayerReadyCancelAck() override;
  explicit constexpr PlayerReadyCancelAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyCancelAck(const PlayerReadyCancelAck& from);
  PlayerReadyCancelAck(PlayerReadyCancelAck&& from) noexcept
    : PlayerReadyCancelAck() {
    *this = ::std::move(from);
  }

  inline PlayerReadyCancelAck& operator=(const PlayerReadyCancelAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyCancelAck& operator=(PlayerReadyCancelAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyCancelAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyCancelAck* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyCancelAck*>(
               &_PlayerReadyCancelAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PlayerReadyCancelAck& a, PlayerReadyCancelAck& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyCancelAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyCancelAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyCancelAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyCancelAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyCancelAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerReadyCancelAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyCancelAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerReadyCancelAck";
  }
  protected:
  explicit PlayerReadyCancelAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerReadyCancelAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyReq) */ {
 public:
  inline GameReadyReq() : GameReadyReq(nullptr) {}
  ~GameReadyReq() override;
  explicit constexpr GameReadyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyReq(const GameReadyReq& from);
  GameReadyReq(GameReadyReq&& from) noexcept
    : GameReadyReq() {
    *this = ::std::move(from);
  }

  inline GameReadyReq& operator=(const GameReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyReq& operator=(GameReadyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyReq* internal_default_instance() {
    return reinterpret_cast<const GameReadyReq*>(
               &_GameReadyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameReadyReq& a, GameReadyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyReq";
  }
  protected:
  explicit GameReadyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameInitNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameInitNtf) */ {
 public:
  inline GameInitNtf() : GameInitNtf(nullptr) {}
  ~GameInitNtf() override;
  explicit constexpr GameInitNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameInitNtf(const GameInitNtf& from);
  GameInitNtf(GameInitNtf&& from) noexcept
    : GameInitNtf() {
    *this = ::std::move(from);
  }

  inline GameInitNtf& operator=(const GameInitNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInitNtf& operator=(GameInitNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameInitNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameInitNtf* internal_default_instance() {
    return reinterpret_cast<const GameInitNtf*>(
               &_GameInitNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GameInitNtf& a, GameInitNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInitNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameInitNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameInitNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameInitNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameInitNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameInitNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInitNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameInitNtf";
  }
  protected:
  explicit GameInitNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdsFieldNumber = 2,
    kRandSeedFieldNumber = 1,
  };
  // repeated .XTankMsg.PlayerId playerIds = 2;
  int playerids_size() const;
  private:
  int _internal_playerids_size() const;
  public:
  void clear_playerids();
  ::XTankMsg::PlayerId* mutable_playerids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
      mutable_playerids();
  private:
  const ::XTankMsg::PlayerId& _internal_playerids(int index) const;
  ::XTankMsg::PlayerId* _internal_add_playerids();
  public:
  const ::XTankMsg::PlayerId& playerids(int index) const;
  ::XTankMsg::PlayerId* add_playerids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
      playerids() const;

  // int32 randSeed = 1;
  void clear_randseed();
  int32_t randseed() const;
  void set_randseed(int32_t value);
  private:
  int32_t _internal_randseed() const;
  void _internal_set_randseed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameInitNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId > playerids_;
  int32_t randseed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyAck) */ {
 public:
  inline GameReadyAck() : GameReadyAck(nullptr) {}
  ~GameReadyAck() override;
  explicit constexpr GameReadyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyAck(const GameReadyAck& from);
  GameReadyAck(GameReadyAck&& from) noexcept
    : GameReadyAck() {
    *this = ::std::move(from);
  }

  inline GameReadyAck& operator=(const GameReadyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyAck& operator=(GameReadyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyAck* internal_default_instance() {
    return reinterpret_cast<const GameReadyAck*>(
               &_GameReadyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameReadyAck& a, GameReadyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyAck";
  }
  protected:
  explicit GameReadyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameStartNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameStartNtf) */ {
 public:
  inline GameStartNtf() : GameStartNtf(nullptr) {}
  ~GameStartNtf() override;
  explicit constexpr GameStartNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartNtf(const GameStartNtf& from);
  GameStartNtf(GameStartNtf&& from) noexcept
    : GameStartNtf() {
    *this = ::std::move(from);
  }

  inline GameStartNtf& operator=(const GameStartNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartNtf& operator=(GameStartNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStartNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartNtf* internal_default_instance() {
    return reinterpret_cast<const GameStartNtf*>(
               &_GameStartNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameStartNtf& a, GameStartNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStartNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameStartNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStartNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameStartNtf";
  }
  protected:
  explicit GameStartNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatencyFieldNumber = 1,
  };
  // float latency = 1;
  void clear_latency();
  float latency() const;
  void set_latency(float value);
  private:
  float _internal_latency() const;
  void _internal_set_latency(float value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameStartNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float latency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerInputNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerInputNtf) */ {
 public:
  inline PlayerInputNtf() : PlayerInputNtf(nullptr) {}
  ~PlayerInputNtf() override;
  explicit constexpr PlayerInputNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInputNtf(const PlayerInputNtf& from);
  PlayerInputNtf(PlayerInputNtf&& from) noexcept
    : PlayerInputNtf() {
    *this = ::std::move(from);
  }

  inline PlayerInputNtf& operator=(const PlayerInputNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInputNtf& operator=(PlayerInputNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInputNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInputNtf* internal_default_instance() {
    return reinterpret_cast<const PlayerInputNtf*>(
               &_PlayerInputNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerInputNtf& a, PlayerInputNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInputNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInputNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInputNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInputNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInputNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerInputNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInputNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerInputNtf";
  }
  protected:
  explicit PlayerInputNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kFrameIdFieldNumber = 2,
    kPlayerCmdFieldNumber = 3,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // uint32 frameId = 2;
  void clear_frameid();
  uint32_t frameid() const;
  void set_frameid(uint32_t value);
  private:
  uint32_t _internal_frameid() const;
  void _internal_set_frameid(uint32_t value);
  public:

  // uint32 playerCmd = 3;
  void clear_playercmd();
  uint32_t playercmd() const;
  void set_playercmd(uint32_t value);
  private:
  uint32_t _internal_playercmd() const;
  void _internal_set_playercmd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerInputNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  uint32_t frameid_;
  uint32_t playercmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameForwardNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameForwardNtf) */ {
 public:
  inline GameForwardNtf() : GameForwardNtf(nullptr) {}
  ~GameForwardNtf() override;
  explicit constexpr GameForwardNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameForwardNtf(const GameForwardNtf& from);
  GameForwardNtf(GameForwardNtf&& from) noexcept
    : GameForwardNtf() {
    *this = ::std::move(from);
  }

  inline GameForwardNtf& operator=(const GameForwardNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameForwardNtf& operator=(GameForwardNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameForwardNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameForwardNtf* internal_default_instance() {
    return reinterpret_cast<const GameForwardNtf*>(
               &_GameForwardNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GameForwardNtf& a, GameForwardNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameForwardNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameForwardNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameForwardNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameForwardNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameForwardNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameForwardNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameForwardNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameForwardNtf";
  }
  protected:
  explicit GameForwardNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerCmdsFieldNumber = 2,
    kFrameIdFieldNumber = 1,
  };
  // repeated uint32 playerCmds = 2;
  int playercmds_size() const;
  private:
  int _internal_playercmds_size() const;
  public:
  void clear_playercmds();
  private:
  uint32_t _internal_playercmds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_playercmds() const;
  void _internal_add_playercmds(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_playercmds();
  public:
  uint32_t playercmds(int index) const;
  void set_playercmds(int index, uint32_t value);
  void add_playercmds(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      playercmds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_playercmds();

  // uint32 frameId = 1;
  void clear_frameid();
  uint32_t frameid() const;
  void set_frameid(uint32_t value);
  private:
  uint32_t _internal_frameid() const;
  void _internal_set_frameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameForwardNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > playercmds_;
  mutable std::atomic<int> _playercmds_cached_byte_size_;
  uint32_t frameid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerExitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerExitReq) */ {
 public:
  inline PlayerExitReq() : PlayerExitReq(nullptr) {}
  ~PlayerExitReq() override;
  explicit constexpr PlayerExitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerExitReq(const PlayerExitReq& from);
  PlayerExitReq(PlayerExitReq&& from) noexcept
    : PlayerExitReq() {
    *this = ::std::move(from);
  }

  inline PlayerExitReq& operator=(const PlayerExitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerExitReq& operator=(PlayerExitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerExitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerExitReq* internal_default_instance() {
    return reinterpret_cast<const PlayerExitReq*>(
               &_PlayerExitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayerExitReq& a, PlayerExitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerExitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerExitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerExitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerExitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerExitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerExitReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerExitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerExitReq";
  }
  protected:
  explicit PlayerExitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerExitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerExitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerExitAck) */ {
 public:
  inline PlayerExitAck() : PlayerExitAck(nullptr) {}
  ~PlayerExitAck() override;
  explicit constexpr PlayerExitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerExitAck(const PlayerExitAck& from);
  PlayerExitAck(PlayerExitAck&& from) noexcept
    : PlayerExitAck() {
    *this = ::std::move(from);
  }

  inline PlayerExitAck& operator=(const PlayerExitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerExitAck& operator=(PlayerExitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerExitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerExitAck* internal_default_instance() {
    return reinterpret_cast<const PlayerExitAck*>(
               &_PlayerExitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PlayerExitAck& a, PlayerExitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerExitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerExitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerExitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerExitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerExitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerExitAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerExitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerExitAck";
  }
  protected:
  explicit PlayerExitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerExitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerCutInReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerCutInReq) */ {
 public:
  inline PlayerCutInReq() : PlayerCutInReq(nullptr) {}
  ~PlayerCutInReq() override;
  explicit constexpr PlayerCutInReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerCutInReq(const PlayerCutInReq& from);
  PlayerCutInReq(PlayerCutInReq&& from) noexcept
    : PlayerCutInReq() {
    *this = ::std::move(from);
  }

  inline PlayerCutInReq& operator=(const PlayerCutInReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCutInReq& operator=(PlayerCutInReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerCutInReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerCutInReq* internal_default_instance() {
    return reinterpret_cast<const PlayerCutInReq*>(
               &_PlayerCutInReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PlayerCutInReq& a, PlayerCutInReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCutInReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerCutInReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerCutInReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerCutInReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerCutInReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerCutInReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCutInReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerCutInReq";
  }
  protected:
  explicit PlayerCutInReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerCutInReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerCutInNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerCutInNtf) */ {
 public:
  inline PlayerCutInNtf() : PlayerCutInNtf(nullptr) {}
  ~PlayerCutInNtf() override;
  explicit constexpr PlayerCutInNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerCutInNtf(const PlayerCutInNtf& from);
  PlayerCutInNtf(PlayerCutInNtf&& from) noexcept
    : PlayerCutInNtf() {
    *this = ::std::move(from);
  }

  inline PlayerCutInNtf& operator=(const PlayerCutInNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCutInNtf& operator=(PlayerCutInNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerCutInNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerCutInNtf* internal_default_instance() {
    return reinterpret_cast<const PlayerCutInNtf*>(
               &_PlayerCutInNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PlayerCutInNtf& a, PlayerCutInNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCutInNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerCutInNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerCutInNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerCutInNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerCutInNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerCutInNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCutInNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerCutInNtf";
  }
  protected:
  explicit PlayerCutInNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdsFieldNumber = 1,
    kCmdsFieldNumber = 2,
  };
  // repeated .XTankMsg.PlayerId playerIds = 1;
  int playerids_size() const;
  private:
  int _internal_playerids_size() const;
  public:
  void clear_playerids();
  ::XTankMsg::PlayerId* mutable_playerids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
      mutable_playerids();
  private:
  const ::XTankMsg::PlayerId& _internal_playerids(int index) const;
  ::XTankMsg::PlayerId* _internal_add_playerids();
  public:
  const ::XTankMsg::PlayerId& playerids(int index) const;
  ::XTankMsg::PlayerId* add_playerids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
      playerids() const;

  // repeated .XTankMsg.GameForwardNtf cmds = 2;
  int cmds_size() const;
  private:
  int _internal_cmds_size() const;
  public:
  void clear_cmds();
  ::XTankMsg::GameForwardNtf* mutable_cmds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::GameForwardNtf >*
      mutable_cmds();
  private:
  const ::XTankMsg::GameForwardNtf& _internal_cmds(int index) const;
  ::XTankMsg::GameForwardNtf* _internal_add_cmds();
  public:
  const ::XTankMsg::GameForwardNtf& cmds(int index) const;
  ::XTankMsg::GameForwardNtf* add_cmds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::GameForwardNtf >&
      cmds() const;

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerCutInNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId > playerids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::GameForwardNtf > cmds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class PlayerChaseUpNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerChaseUpNtf) */ {
 public:
  inline PlayerChaseUpNtf() : PlayerChaseUpNtf(nullptr) {}
  ~PlayerChaseUpNtf() override;
  explicit constexpr PlayerChaseUpNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerChaseUpNtf(const PlayerChaseUpNtf& from);
  PlayerChaseUpNtf(PlayerChaseUpNtf&& from) noexcept
    : PlayerChaseUpNtf() {
    *this = ::std::move(from);
  }

  inline PlayerChaseUpNtf& operator=(const PlayerChaseUpNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerChaseUpNtf& operator=(PlayerChaseUpNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerChaseUpNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerChaseUpNtf* internal_default_instance() {
    return reinterpret_cast<const PlayerChaseUpNtf*>(
               &_PlayerChaseUpNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PlayerChaseUpNtf& a, PlayerChaseUpNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerChaseUpNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerChaseUpNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerChaseUpNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerChaseUpNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerChaseUpNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerChaseUpNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerChaseUpNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerChaseUpNtf";
  }
  protected:
  explicit PlayerChaseUpNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerChaseUpNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerId

// string ip = 1;
inline void PlayerId::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& PlayerId::ip() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerId.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerId::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerId.ip)
}
inline std::string* PlayerId::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerId.ip)
  return _s;
}
inline const std::string& PlayerId::_internal_ip() const {
  return ip_.Get();
}
inline void PlayerId::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerId::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerId::release_ip() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerId.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerId::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerId.ip)
}

// uint64 pid = 2;
inline void PlayerId::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t PlayerId::_internal_pid() const {
  return pid_;
}
inline uint64_t PlayerId::pid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerId.pid)
  return _internal_pid();
}
inline void PlayerId::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void PlayerId::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerId.pid)
}

// -------------------------------------------------------------------

// LoginReq

// .XTankMsg.PlayerId playerId = 1;
inline bool LoginReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool LoginReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void LoginReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& LoginReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& LoginReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginReq.playerId)
  return _internal_playerid();
}
inline void LoginReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.LoginReq.playerId)
}
inline ::XTankMsg::PlayerId* LoginReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* LoginReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.LoginReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* LoginReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* LoginReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LoginReq.playerId)
  return _msg;
}
inline void LoginReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LoginReq.playerId)
}

// -------------------------------------------------------------------

// LoginAck

// bool success = 1;
inline void LoginAck::clear_success() {
  success_ = false;
}
inline bool LoginAck::_internal_success() const {
  return success_;
}
inline bool LoginAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginAck.success)
  return _internal_success();
}
inline void LoginAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LoginAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LoginAck.success)
}

// string msg = 2;
inline void LoginAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& LoginAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.LoginAck.msg)
}
inline std::string* LoginAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LoginAck.msg)
  return _s;
}
inline const std::string& LoginAck::_internal_msg() const {
  return msg_.Get();
}
inline void LoginAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.LoginAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LoginAck.msg)
}

// -------------------------------------------------------------------

// LogoutReq

// .XTankMsg.PlayerId playerId = 1;
inline bool LogoutReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool LogoutReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void LogoutReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& LogoutReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& LogoutReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutReq.playerId)
  return _internal_playerid();
}
inline void LogoutReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.LogoutReq.playerId)
}
inline ::XTankMsg::PlayerId* LogoutReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* LogoutReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.LogoutReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* LogoutReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* LogoutReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LogoutReq.playerId)
  return _msg;
}
inline void LogoutReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LogoutReq.playerId)
}

// -------------------------------------------------------------------

// LogoutAck

// bool success = 1;
inline void LogoutAck::clear_success() {
  success_ = false;
}
inline bool LogoutAck::_internal_success() const {
  return success_;
}
inline bool LogoutAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutAck.success)
  return _internal_success();
}
inline void LogoutAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LogoutAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LogoutAck.success)
}

// string msg = 2;
inline void LogoutAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& LogoutAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.LogoutAck.msg)
}
inline std::string* LogoutAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LogoutAck.msg)
  return _s;
}
inline const std::string& LogoutAck::_internal_msg() const {
  return msg_.Get();
}
inline void LogoutAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogoutAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogoutAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.LogoutAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogoutAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LogoutAck.msg)
}

// -------------------------------------------------------------------

// LobbyNtf_RoomInfo

// uint32 id = 1;
inline void LobbyNtf_RoomInfo::clear_id() {
  id_ = 0u;
}
inline uint32_t LobbyNtf_RoomInfo::_internal_id() const {
  return id_;
}
inline uint32_t LobbyNtf_RoomInfo::id() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.id)
  return _internal_id();
}
inline void LobbyNtf_RoomInfo::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void LobbyNtf_RoomInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.id)
}

// uint32 playerNum = 2;
inline void LobbyNtf_RoomInfo::clear_playernum() {
  playernum_ = 0u;
}
inline uint32_t LobbyNtf_RoomInfo::_internal_playernum() const {
  return playernum_;
}
inline uint32_t LobbyNtf_RoomInfo::playernum() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.playerNum)
  return _internal_playernum();
}
inline void LobbyNtf_RoomInfo::_internal_set_playernum(uint32_t value) {
  
  playernum_ = value;
}
inline void LobbyNtf_RoomInfo::set_playernum(uint32_t value) {
  _internal_set_playernum(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.playerNum)
}

// bool inGame = 3;
inline void LobbyNtf_RoomInfo::clear_ingame() {
  ingame_ = false;
}
inline bool LobbyNtf_RoomInfo::_internal_ingame() const {
  return ingame_;
}
inline bool LobbyNtf_RoomInfo::ingame() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.inGame)
  return _internal_ingame();
}
inline void LobbyNtf_RoomInfo::_internal_set_ingame(bool value) {
  
  ingame_ = value;
}
inline void LobbyNtf_RoomInfo::set_ingame(bool value) {
  _internal_set_ingame(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.inGame)
}

// -------------------------------------------------------------------

// LobbyNtf

// repeated .XTankMsg.LobbyNtf.RoomInfo rooms = 1;
inline int LobbyNtf::_internal_rooms_size() const {
  return rooms_.size();
}
inline int LobbyNtf::rooms_size() const {
  return _internal_rooms_size();
}
inline void LobbyNtf::clear_rooms() {
  rooms_.Clear();
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.LobbyNtf.rooms)
  return rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >*
LobbyNtf::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.LobbyNtf.rooms)
  return &rooms_;
}
inline const ::XTankMsg::LobbyNtf_RoomInfo& LobbyNtf::_internal_rooms(int index) const {
  return rooms_.Get(index);
}
inline const ::XTankMsg::LobbyNtf_RoomInfo& LobbyNtf::rooms(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.rooms)
  return _internal_rooms(index);
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::_internal_add_rooms() {
  return rooms_.Add();
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::add_rooms() {
  ::XTankMsg::LobbyNtf_RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:XTankMsg.LobbyNtf.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >&
LobbyNtf::rooms() const {
  // @@protoc_insertion_point(field_list:XTankMsg.LobbyNtf.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// RoomCreateReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomCreateReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomCreateReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomCreateReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomCreateReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomCreateReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateReq.playerId)
  return _internal_playerid();
}
inline void RoomCreateReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomCreateReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomCreateReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomCreateReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomCreateReq.playerId)
  return _msg;
}
inline void RoomCreateReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomCreateReq.playerId)
}

// -------------------------------------------------------------------

// RoomCreateAck

// bool success = 1;
inline void RoomCreateAck::clear_success() {
  success_ = false;
}
inline bool RoomCreateAck::_internal_success() const {
  return success_;
}
inline bool RoomCreateAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateAck.success)
  return _internal_success();
}
inline void RoomCreateAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomCreateAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomCreateAck.success)
}

// string msg = 2;
inline void RoomCreateAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomCreateAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomCreateAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomCreateAck.msg)
}
inline std::string* RoomCreateAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomCreateAck.msg)
  return _s;
}
inline const std::string& RoomCreateAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomCreateAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomCreateAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomCreateAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomCreateAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomCreateAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomCreateAck.msg)
}

// -------------------------------------------------------------------

// RoomJoinReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomJoinReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomJoinReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomJoinReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomJoinReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomJoinReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinReq.playerId)
  return _internal_playerid();
}
inline void RoomJoinReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomJoinReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomJoinReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomJoinReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomJoinReq.playerId)
  return _msg;
}
inline void RoomJoinReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomJoinReq.playerId)
}

// uint64 roomId = 2;
inline void RoomJoinReq::clear_roomid() {
  roomid_ = uint64_t{0u};
}
inline uint64_t RoomJoinReq::_internal_roomid() const {
  return roomid_;
}
inline uint64_t RoomJoinReq::roomid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinReq.roomId)
  return _internal_roomid();
}
inline void RoomJoinReq::_internal_set_roomid(uint64_t value) {
  
  roomid_ = value;
}
inline void RoomJoinReq::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinReq.roomId)
}

// -------------------------------------------------------------------

// RoomJoinAck

// bool success = 1;
inline void RoomJoinAck::clear_success() {
  success_ = false;
}
inline bool RoomJoinAck::_internal_success() const {
  return success_;
}
inline bool RoomJoinAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinAck.success)
  return _internal_success();
}
inline void RoomJoinAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomJoinAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinAck.success)
}

// string msg = 2;
inline void RoomJoinAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomJoinAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomJoinAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinAck.msg)
}
inline std::string* RoomJoinAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomJoinAck.msg)
  return _s;
}
inline const std::string& RoomJoinAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomJoinAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomJoinAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomJoinAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomJoinAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomJoinAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomJoinAck.msg)
}

// -------------------------------------------------------------------

// RoomExitReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomExitReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomExitReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomExitReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomExitReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomExitReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitReq.playerId)
  return _internal_playerid();
}
inline void RoomExitReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomExitReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomExitReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomExitReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomExitReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomExitReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomExitReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomExitReq.playerId)
  return _msg;
}
inline void RoomExitReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomExitReq.playerId)
}

// -------------------------------------------------------------------

// RoomExitAck

// bool success = 1;
inline void RoomExitAck::clear_success() {
  success_ = false;
}
inline bool RoomExitAck::_internal_success() const {
  return success_;
}
inline bool RoomExitAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitAck.success)
  return _internal_success();
}
inline void RoomExitAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomExitAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomExitAck.success)
}

// string msg = 2;
inline void RoomExitAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomExitAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomExitAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomExitAck.msg)
}
inline std::string* RoomExitAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomExitAck.msg)
  return _s;
}
inline const std::string& RoomExitAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomExitAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomExitAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomExitAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomExitAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomExitAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomExitAck.msg)
}

// -------------------------------------------------------------------

// RoomNtf_PlayerState

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomNtf_PlayerState::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomNtf_PlayerState::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomNtf_PlayerState::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomNtf_PlayerState::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomNtf_PlayerState::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.PlayerState.playerId)
  return _internal_playerid();
}
inline void RoomNtf_PlayerState::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomNtf.PlayerState.playerId)
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomNtf.PlayerState.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomNtf.PlayerState.playerId)
  return _msg;
}
inline void RoomNtf_PlayerState::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomNtf.PlayerState.playerId)
}

// bool ready = 2;
inline void RoomNtf_PlayerState::clear_ready() {
  ready_ = false;
}
inline bool RoomNtf_PlayerState::_internal_ready() const {
  return ready_;
}
inline bool RoomNtf_PlayerState::ready() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.PlayerState.ready)
  return _internal_ready();
}
inline void RoomNtf_PlayerState::_internal_set_ready(bool value) {
  
  ready_ = value;
}
inline void RoomNtf_PlayerState::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomNtf.PlayerState.ready)
}

// -------------------------------------------------------------------

// RoomNtf

// uint32 roomId = 1;
inline void RoomNtf::clear_roomid() {
  roomid_ = 0u;
}
inline uint32_t RoomNtf::_internal_roomid() const {
  return roomid_;
}
inline uint32_t RoomNtf::roomid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.roomId)
  return _internal_roomid();
}
inline void RoomNtf::_internal_set_roomid(uint32_t value) {
  
  roomid_ = value;
}
inline void RoomNtf::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomNtf.roomId)
}

// repeated .XTankMsg.RoomNtf.PlayerState playerStates = 2;
inline int RoomNtf::_internal_playerstates_size() const {
  return playerstates_.size();
}
inline int RoomNtf::playerstates_size() const {
  return _internal_playerstates_size();
}
inline void RoomNtf::clear_playerstates() {
  playerstates_.Clear();
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::mutable_playerstates(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomNtf.playerStates)
  return playerstates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >*
RoomNtf::mutable_playerstates() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.RoomNtf.playerStates)
  return &playerstates_;
}
inline const ::XTankMsg::RoomNtf_PlayerState& RoomNtf::_internal_playerstates(int index) const {
  return playerstates_.Get(index);
}
inline const ::XTankMsg::RoomNtf_PlayerState& RoomNtf::playerstates(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.playerStates)
  return _internal_playerstates(index);
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::_internal_add_playerstates() {
  return playerstates_.Add();
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::add_playerstates() {
  ::XTankMsg::RoomNtf_PlayerState* _add = _internal_add_playerstates();
  // @@protoc_insertion_point(field_add:XTankMsg.RoomNtf.playerStates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >&
RoomNtf::playerstates() const {
  // @@protoc_insertion_point(field_list:XTankMsg.RoomNtf.playerStates)
  return playerstates_;
}

// bool IsInGame = 3;
inline void RoomNtf::clear_isingame() {
  isingame_ = false;
}
inline bool RoomNtf::_internal_isingame() const {
  return isingame_;
}
inline bool RoomNtf::isingame() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.IsInGame)
  return _internal_isingame();
}
inline void RoomNtf::_internal_set_isingame(bool value) {
  
  isingame_ = value;
}
inline void RoomNtf::set_isingame(bool value) {
  _internal_set_isingame(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomNtf.IsInGame)
}

// -------------------------------------------------------------------

// PlayerReadyReq

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerReadyReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerReadyReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerReadyReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerReadyReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerReadyReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyReq.playerId)
  return _internal_playerid();
}
inline void PlayerReadyReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerReadyReq.playerId)
}
inline ::XTankMsg::PlayerId* PlayerReadyReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerReadyReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerReadyReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerReadyReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerReadyReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerReadyReq.playerId)
  return _msg;
}
inline void PlayerReadyReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerReadyReq.playerId)
}

// -------------------------------------------------------------------

// PlayerReadyAck

// bool success = 1;
inline void PlayerReadyAck::clear_success() {
  success_ = false;
}
inline bool PlayerReadyAck::_internal_success() const {
  return success_;
}
inline bool PlayerReadyAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyAck.success)
  return _internal_success();
}
inline void PlayerReadyAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PlayerReadyAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerReadyAck.success)
}

// string msg = 2;
inline void PlayerReadyAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& PlayerReadyAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerReadyAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerReadyAck.msg)
}
inline std::string* PlayerReadyAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerReadyAck.msg)
  return _s;
}
inline const std::string& PlayerReadyAck::_internal_msg() const {
  return msg_.Get();
}
inline void PlayerReadyAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerReadyAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerReadyAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerReadyAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerReadyAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerReadyAck.msg)
}

// -------------------------------------------------------------------

// PlayerReadyCancelReq

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerReadyCancelReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerReadyCancelReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerReadyCancelReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerReadyCancelReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerReadyCancelReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyCancelReq.playerId)
  return _internal_playerid();
}
inline void PlayerReadyCancelReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerReadyCancelReq.playerId)
}
inline ::XTankMsg::PlayerId* PlayerReadyCancelReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerReadyCancelReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerReadyCancelReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerReadyCancelReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerReadyCancelReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerReadyCancelReq.playerId)
  return _msg;
}
inline void PlayerReadyCancelReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerReadyCancelReq.playerId)
}

// -------------------------------------------------------------------

// PlayerReadyCancelAck

// bool success = 1;
inline void PlayerReadyCancelAck::clear_success() {
  success_ = false;
}
inline bool PlayerReadyCancelAck::_internal_success() const {
  return success_;
}
inline bool PlayerReadyCancelAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyCancelAck.success)
  return _internal_success();
}
inline void PlayerReadyCancelAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PlayerReadyCancelAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerReadyCancelAck.success)
}

// string msg = 2;
inline void PlayerReadyCancelAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& PlayerReadyCancelAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerReadyCancelAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerReadyCancelAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerReadyCancelAck.msg)
}
inline std::string* PlayerReadyCancelAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerReadyCancelAck.msg)
  return _s;
}
inline const std::string& PlayerReadyCancelAck::_internal_msg() const {
  return msg_.Get();
}
inline void PlayerReadyCancelAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerReadyCancelAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerReadyCancelAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerReadyCancelAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerReadyCancelAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerReadyCancelAck.msg)
}

// -------------------------------------------------------------------

// GameReadyReq

// bool success = 1;
inline void GameReadyReq::clear_success() {
  success_ = false;
}
inline bool GameReadyReq::_internal_success() const {
  return success_;
}
inline bool GameReadyReq::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyReq.success)
  return _internal_success();
}
inline void GameReadyReq::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GameReadyReq::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyReq.success)
}

// -------------------------------------------------------------------

// GameInitNtf

// int32 randSeed = 1;
inline void GameInitNtf::clear_randseed() {
  randseed_ = 0;
}
inline int32_t GameInitNtf::_internal_randseed() const {
  return randseed_;
}
inline int32_t GameInitNtf::randseed() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameInitNtf.randSeed)
  return _internal_randseed();
}
inline void GameInitNtf::_internal_set_randseed(int32_t value) {
  
  randseed_ = value;
}
inline void GameInitNtf::set_randseed(int32_t value) {
  _internal_set_randseed(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameInitNtf.randSeed)
}

// repeated .XTankMsg.PlayerId playerIds = 2;
inline int GameInitNtf::_internal_playerids_size() const {
  return playerids_.size();
}
inline int GameInitNtf::playerids_size() const {
  return _internal_playerids_size();
}
inline void GameInitNtf::clear_playerids() {
  playerids_.Clear();
}
inline ::XTankMsg::PlayerId* GameInitNtf::mutable_playerids(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameInitNtf.playerIds)
  return playerids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
GameInitNtf::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.GameInitNtf.playerIds)
  return &playerids_;
}
inline const ::XTankMsg::PlayerId& GameInitNtf::_internal_playerids(int index) const {
  return playerids_.Get(index);
}
inline const ::XTankMsg::PlayerId& GameInitNtf::playerids(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameInitNtf.playerIds)
  return _internal_playerids(index);
}
inline ::XTankMsg::PlayerId* GameInitNtf::_internal_add_playerids() {
  return playerids_.Add();
}
inline ::XTankMsg::PlayerId* GameInitNtf::add_playerids() {
  ::XTankMsg::PlayerId* _add = _internal_add_playerids();
  // @@protoc_insertion_point(field_add:XTankMsg.GameInitNtf.playerIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
GameInitNtf::playerids() const {
  // @@protoc_insertion_point(field_list:XTankMsg.GameInitNtf.playerIds)
  return playerids_;
}

// -------------------------------------------------------------------

// GameReadyAck

// .XTankMsg.PlayerId playerId = 1;
inline bool GameReadyAck::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool GameReadyAck::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameReadyAck::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& GameReadyAck::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& GameReadyAck::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyAck.playerId)
  return _internal_playerid();
}
inline void GameReadyAck::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.GameReadyAck.playerId)
}
inline ::XTankMsg::PlayerId* GameReadyAck::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyAck::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyAck.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyAck::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* GameReadyAck::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyAck.playerId)
  return _msg;
}
inline void GameReadyAck::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyAck.playerId)
}

// -------------------------------------------------------------------

// GameStartNtf

// float latency = 1;
inline void GameStartNtf::clear_latency() {
  latency_ = 0;
}
inline float GameStartNtf::_internal_latency() const {
  return latency_;
}
inline float GameStartNtf::latency() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameStartNtf.latency)
  return _internal_latency();
}
inline void GameStartNtf::_internal_set_latency(float value) {
  
  latency_ = value;
}
inline void GameStartNtf::set_latency(float value) {
  _internal_set_latency(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameStartNtf.latency)
}

// -------------------------------------------------------------------

// PlayerInputNtf

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerInputNtf::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerInputNtf::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerInputNtf::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerInputNtf::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerInputNtf::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerInputNtf.playerId)
  return _internal_playerid();
}
inline void PlayerInputNtf::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerInputNtf.playerId)
}
inline ::XTankMsg::PlayerId* PlayerInputNtf::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerInputNtf::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerInputNtf.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerInputNtf::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerInputNtf::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerInputNtf.playerId)
  return _msg;
}
inline void PlayerInputNtf::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerInputNtf.playerId)
}

// uint32 frameId = 2;
inline void PlayerInputNtf::clear_frameid() {
  frameid_ = 0u;
}
inline uint32_t PlayerInputNtf::_internal_frameid() const {
  return frameid_;
}
inline uint32_t PlayerInputNtf::frameid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerInputNtf.frameId)
  return _internal_frameid();
}
inline void PlayerInputNtf::_internal_set_frameid(uint32_t value) {
  
  frameid_ = value;
}
inline void PlayerInputNtf::set_frameid(uint32_t value) {
  _internal_set_frameid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerInputNtf.frameId)
}

// uint32 playerCmd = 3;
inline void PlayerInputNtf::clear_playercmd() {
  playercmd_ = 0u;
}
inline uint32_t PlayerInputNtf::_internal_playercmd() const {
  return playercmd_;
}
inline uint32_t PlayerInputNtf::playercmd() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerInputNtf.playerCmd)
  return _internal_playercmd();
}
inline void PlayerInputNtf::_internal_set_playercmd(uint32_t value) {
  
  playercmd_ = value;
}
inline void PlayerInputNtf::set_playercmd(uint32_t value) {
  _internal_set_playercmd(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerInputNtf.playerCmd)
}

// -------------------------------------------------------------------

// GameForwardNtf

// uint32 frameId = 1;
inline void GameForwardNtf::clear_frameid() {
  frameid_ = 0u;
}
inline uint32_t GameForwardNtf::_internal_frameid() const {
  return frameid_;
}
inline uint32_t GameForwardNtf::frameid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameForwardNtf.frameId)
  return _internal_frameid();
}
inline void GameForwardNtf::_internal_set_frameid(uint32_t value) {
  
  frameid_ = value;
}
inline void GameForwardNtf::set_frameid(uint32_t value) {
  _internal_set_frameid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameForwardNtf.frameId)
}

// repeated uint32 playerCmds = 2;
inline int GameForwardNtf::_internal_playercmds_size() const {
  return playercmds_.size();
}
inline int GameForwardNtf::playercmds_size() const {
  return _internal_playercmds_size();
}
inline void GameForwardNtf::clear_playercmds() {
  playercmds_.Clear();
}
inline uint32_t GameForwardNtf::_internal_playercmds(int index) const {
  return playercmds_.Get(index);
}
inline uint32_t GameForwardNtf::playercmds(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_playercmds(index);
}
inline void GameForwardNtf::set_playercmds(int index, uint32_t value) {
  playercmds_.Set(index, value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameForwardNtf.playerCmds)
}
inline void GameForwardNtf::_internal_add_playercmds(uint32_t value) {
  playercmds_.Add(value);
}
inline void GameForwardNtf::add_playercmds(uint32_t value) {
  _internal_add_playercmds(value);
  // @@protoc_insertion_point(field_add:XTankMsg.GameForwardNtf.playerCmds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameForwardNtf::_internal_playercmds() const {
  return playercmds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameForwardNtf::playercmds() const {
  // @@protoc_insertion_point(field_list:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_playercmds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameForwardNtf::_internal_mutable_playercmds() {
  return &playercmds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameForwardNtf::mutable_playercmds() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_mutable_playercmds();
}

// -------------------------------------------------------------------

// PlayerExitReq

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerExitReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerExitReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerExitReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerExitReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerExitReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerExitReq.playerId)
  return _internal_playerid();
}
inline void PlayerExitReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerExitReq.playerId)
}
inline ::XTankMsg::PlayerId* PlayerExitReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerExitReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerExitReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerExitReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerExitReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerExitReq.playerId)
  return _msg;
}
inline void PlayerExitReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerExitReq.playerId)
}

// -------------------------------------------------------------------

// PlayerExitAck

// bool success = 1;
inline void PlayerExitAck::clear_success() {
  success_ = false;
}
inline bool PlayerExitAck::_internal_success() const {
  return success_;
}
inline bool PlayerExitAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerExitAck.success)
  return _internal_success();
}
inline void PlayerExitAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PlayerExitAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerExitAck.success)
}

// string msg = 2;
inline void PlayerExitAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& PlayerExitAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerExitAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerExitAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerExitAck.msg)
}
inline std::string* PlayerExitAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerExitAck.msg)
  return _s;
}
inline const std::string& PlayerExitAck::_internal_msg() const {
  return msg_.Get();
}
inline void PlayerExitAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerExitAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerExitAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerExitAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerExitAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerExitAck.msg)
}

// -------------------------------------------------------------------

// PlayerCutInReq

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerCutInReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerCutInReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerCutInReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerCutInReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerCutInReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerCutInReq.playerId)
  return _internal_playerid();
}
inline void PlayerCutInReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerCutInReq.playerId)
}
inline ::XTankMsg::PlayerId* PlayerCutInReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerCutInReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerCutInReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerCutInReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerCutInReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerCutInReq.playerId)
  return _msg;
}
inline void PlayerCutInReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerCutInReq.playerId)
}

// -------------------------------------------------------------------

// PlayerCutInNtf

// repeated .XTankMsg.PlayerId playerIds = 1;
inline int PlayerCutInNtf::_internal_playerids_size() const {
  return playerids_.size();
}
inline int PlayerCutInNtf::playerids_size() const {
  return _internal_playerids_size();
}
inline void PlayerCutInNtf::clear_playerids() {
  playerids_.Clear();
}
inline ::XTankMsg::PlayerId* PlayerCutInNtf::mutable_playerids(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerCutInNtf.playerIds)
  return playerids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
PlayerCutInNtf::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.PlayerCutInNtf.playerIds)
  return &playerids_;
}
inline const ::XTankMsg::PlayerId& PlayerCutInNtf::_internal_playerids(int index) const {
  return playerids_.Get(index);
}
inline const ::XTankMsg::PlayerId& PlayerCutInNtf::playerids(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerCutInNtf.playerIds)
  return _internal_playerids(index);
}
inline ::XTankMsg::PlayerId* PlayerCutInNtf::_internal_add_playerids() {
  return playerids_.Add();
}
inline ::XTankMsg::PlayerId* PlayerCutInNtf::add_playerids() {
  ::XTankMsg::PlayerId* _add = _internal_add_playerids();
  // @@protoc_insertion_point(field_add:XTankMsg.PlayerCutInNtf.playerIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
PlayerCutInNtf::playerids() const {
  // @@protoc_insertion_point(field_list:XTankMsg.PlayerCutInNtf.playerIds)
  return playerids_;
}

// repeated .XTankMsg.GameForwardNtf cmds = 2;
inline int PlayerCutInNtf::_internal_cmds_size() const {
  return cmds_.size();
}
inline int PlayerCutInNtf::cmds_size() const {
  return _internal_cmds_size();
}
inline void PlayerCutInNtf::clear_cmds() {
  cmds_.Clear();
}
inline ::XTankMsg::GameForwardNtf* PlayerCutInNtf::mutable_cmds(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerCutInNtf.cmds)
  return cmds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::GameForwardNtf >*
PlayerCutInNtf::mutable_cmds() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.PlayerCutInNtf.cmds)
  return &cmds_;
}
inline const ::XTankMsg::GameForwardNtf& PlayerCutInNtf::_internal_cmds(int index) const {
  return cmds_.Get(index);
}
inline const ::XTankMsg::GameForwardNtf& PlayerCutInNtf::cmds(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerCutInNtf.cmds)
  return _internal_cmds(index);
}
inline ::XTankMsg::GameForwardNtf* PlayerCutInNtf::_internal_add_cmds() {
  return cmds_.Add();
}
inline ::XTankMsg::GameForwardNtf* PlayerCutInNtf::add_cmds() {
  ::XTankMsg::GameForwardNtf* _add = _internal_add_cmds();
  // @@protoc_insertion_point(field_add:XTankMsg.PlayerCutInNtf.cmds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::GameForwardNtf >&
PlayerCutInNtf::cmds() const {
  // @@protoc_insertion_point(field_list:XTankMsg.PlayerCutInNtf.cmds)
  return cmds_;
}

// -------------------------------------------------------------------

// PlayerChaseUpNtf

// .XTankMsg.PlayerId playerId = 1;
inline bool PlayerChaseUpNtf::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool PlayerChaseUpNtf::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerChaseUpNtf::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& PlayerChaseUpNtf::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& PlayerChaseUpNtf::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerChaseUpNtf.playerId)
  return _internal_playerid();
}
inline void PlayerChaseUpNtf::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.PlayerChaseUpNtf.playerId)
}
inline ::XTankMsg::PlayerId* PlayerChaseUpNtf::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerChaseUpNtf::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerChaseUpNtf.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* PlayerChaseUpNtf::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* PlayerChaseUpNtf::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerChaseUpNtf.playerId)
  return _msg;
}
inline void PlayerChaseUpNtf::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerChaseUpNtf.playerId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XTankMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XTankMsg::MSG> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XTankMsg::MSG>() {
  return ::XTankMsg::MSG_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto
